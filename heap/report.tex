\documentclass{article}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{ctex} % 支持中文
\usepackage[a4paper, left=1.0cm, right=1.0cm, top=1.0cm, bottom=1.0cm]{geometry} % 调整页边距
\usepackage{longtable}

\title{堆排序算法实现与性能评估}
\author{王珩宁}
\date{\today}

\begin{document}

\maketitle

\section{引言}
我们实现了一个自定义的堆排序算法以及与 C++ 标准库中的 ''\texttt{std::sort\_heap}'' 进行的比较。并对其在不同类型的数据集上的表现进行了测试

\section{设计与实现}
这一节是堆排序的设计和实现。首先，堆排序具体怎么实现它。最后，怎么做了一些优化，让它跑得更快一些。

\subsection{堆排序算法的设计}
堆排序其实是基于堆这种数据结构来排序的，堆就是一棵特殊的树。这里我们使用的是最大堆(Max-Heap)，意思是每个节点的值都大于或等于它的子节点。这就确保了堆顶总是最大的那个元素。

堆排序的核心思想就是：我们先把数据按照堆的结构整理好，然后从堆顶取出最大的元素，把它放到数组的最后。接着，我们再调整剩下的数据，使得它们依然符合堆的规则。这样一步步做，最终就能把数据排好。

堆排序大体可以分为两个步骤：

1. 构建最大堆：首先，我们需要把数组调整成最大堆。从最后一个非叶子节点开始，我们逐步调整每个节点，确保父节点大于等于它的子节点。这个调整过程会从下到上，直到整个数组变成最大堆。
   
2. 排序：一旦构建好了最大堆就开始排序。每次我们把堆顶(最大元素)和当前堆的最后一个元素交换，交换完后堆的大小减一。然后，调整堆，保证堆顶仍然是最大元素。这个过程反复进行，直到数组完全排好。

堆排序的时间复杂度是 $O(n \log n)$，还是很快的。

\subsection{优化与实现}
虽然基于std向量堆排序已经是一个高效的排序算法，但我们还是希望它能跑得更快一些。主要有两个地方：

1. 快速交换：每次堆顶和最后一个元素交换时，我们需要交换两个元素的位置。一般来说，交换操作可以通过标准的 ''\texttt{std::swap}'' 来完成，但我们觉得用标准交换的方式会有一点小开销。于是我们用了一种快速交换的方法，它通过异或操作来交换两个元素，这样就不需要额外的临时变量，效率就更高了。虽然这个优化不会对每一步都产生特别大的影响，但当数据量很大时，这种细节上的优化可以带来显著的性能提升。

2. 递归调整堆：我们用递归的方式来调整堆，每次递归调整一个节点，使它和它的子树都合乎堆的性质。这种递归方式其实比较简单，也容易理解。但是当数据量特别大的时候，递归深度会很深，栈空间会用得比较多。如果真的有这种情况，我们也可以把递归改成非递归的方式，减少栈空间的消耗。

总的来说，通过这些优化，我们的堆排序在执行时的性能得到了提升，尤其是在处理大量数据时，优化的效果更加明显。

堆排序不是稳定排序，意味着相等的元素排序后可能会发生顺序变化。如果需要稳定排序，还是得选择别的。总的来说，堆排序在很多实际场景下都能很好地完成任务，尤其是在对时间效率要求较高的时候。

\subsection{优化与实现}
记录了每次排序所花费的时间，两个排序算法对四种队列分别测试，共得到四组结果。
使用chrono计算用时，得到的时间单位是毫秒。
\section{测试结果}

每个测试序列的长度都至少为 1,000,000。我们还将自定义的堆排序与 ''\texttt{std::sort\_heap}'' 进行了对比，记录了每次排序所花费的时间。以下是测试结果：

\begin{longtable}{|l|l|l|}
\hline
\textbf{序列类型} & \textbf{我写的(ms)} & \textbf{std::sort\_heap(ms)} \\
\hline
\endfirsthead
\hline
\textbf{序列类型} & \textbf{我写的(ms)} & \textbf{std::sort\_heap(ms)} \\
\hline
\endhead
\hline
\textbf{随机序列} & 572 & 752 \\
\textbf{有序序列} & 357 & 570 \\
\textbf{逆序序列} & 359 & 586 \\
\textbf{重复元素序列} & 467 & 695 \\
\hline
\end{longtable}

\subsection{性能差异原因分析}

两个排序程序的复杂度都是 $O(n \log n)$，但是我们的堆排序在都比 ''\texttt{std::sort\_heap}'' 要快。
自定义堆排序比 ''\texttt{std::sort\_heap}'' 更快，主要归因于几个实现细节的优化。首先，在交换操作方面，自定义实现使用了 fastSwap(位运算交换)来代替 ''\texttt{std::swap}''，这种方式比标准的交换函数更高效，尤其在堆排序过程中需要频繁交换元素时，能够减少内存访问和临时对象的创建。而 ''\texttt{std::sort\_heap}'' 使用标准的 ''\texttt{std::swap}''，虽然它经过优化，但在频繁交换的情况下，其性能不如 fastSwap。

其次，自定义堆排序使用了 迭代版的 heapify，避免了递归调用的栈开销。在堆化操作中，递归方式会带来额外的函数调用和栈空间消耗，而迭代方式直接使用 while 循环，使得每次堆化都更加高效。相比之下，''\texttt{std::sort\_heap}'' 采用递归堆化，在处理大量数据时会受到递归栈开销的影响。

另外，''\texttt{std::sort\_heap}'' 是为了通用性和可移植性设计的。实现虽然进行了内存对齐、缓存优化等通用优化，但这些优化是为了兼容更多的硬件和数据类型，而且还会对 ''\texttt{\_\_glibcxx\_requires\_valid\_range(\_\_first, \_\_last);} \texttt{\_\_glibcxx\_requires\_irreflexive(\_\_first, \_\_last);}'' 这些东西做检查。而自定义堆排序通过直接优化堆结构的内存访问，提高了缓存命中率和内存利用率，从而减少了不必要的内存访问和计算开销。

总之就是前者检查更多所以更慢，但是稳定性更强，后者适用范围小，可移植性拉，所以性能快一些。

\end{document}
