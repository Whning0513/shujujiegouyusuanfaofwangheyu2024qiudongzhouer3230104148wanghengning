\documentclass{article}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{ctex} % 支持中文
\usepackage[a4paper, left=1.0cm, right=1.0cm, top=1.0cm, bottom=1.0cm]{geometry} % 调整页边距

\title{二叉搜索树删除函数优化测试报告}
\author{王珩宁3230104148}
\date{\today}

\begin{document}

\maketitle

\section{引言}
这次作业把原来的二叉搜索树变成了avl树，通过对不同高度树的结构进行旋转操作，确保每次插入和删除操作后树的平衡性，把树变得比较像一个三角形。这些优化可以显著提高树的操作效率，可以避免“一大条树”导致的性能方差问题，可以让插入和删除都在O(lnx)的水平，增加效率。

\section{删除函数的修改}
在传统的二叉搜索树（BST）中，删除节点的操作遵循以下规则：
\begin{enumerate}
    \item 如果节点没有子节点，直接删除。
    \item 如果节点有一个子节点，吧指向这个节点的指针指向这个节点的子节点。
    \item 如果节点有两个子节点，有两种删除方法，在课堂上我们的做法事将右子树中的最小元素替换当前节点。然后递归删除该最小节点。
\end{enumerate}

但是因为删除的时候会删除该删除的节点，所以容易出现性能问题，对于树形如(1,……(1,NULL,NULL),……NULL)等等，退化的越来越像链表，那么作为树的删除效率O(lnx)就会退化成worstcase的O(n)。所以我们需要对删除函数进行优化。于是就要用avl树的模式，把高度旋转来平衡，把长的短的变成一样长的，以此来规避性能浪费。
我们给每一个树的节点的struct都引入了一个高度。在删除一个节点后，我们需要检查树的平衡性。avl树要求任何一个节点的左右子树的高度差不能超过正负1。删除操作可能导致树的某些部分失衡，再通过四种旋转操作恢复平衡，让高度差的绝对值小于等于1。通过检查节点的平衡因子（局部的高度差）来判断是否需要进行旋转操作。
每次删除节点后，我们会检查其parent的平衡因子。如果平衡因子的绝对值大于1，则说明树失衡。我们avl树支持四种类型的旋转来恢复平衡：(在代码中是第400行起)
\begin{enumerate}
    \item \textbf{左-左失衡（LL）}：如果父节点的左子树比右子树重，并且左子树的左子树比右子树重，执行单右旋。
    \item \textbf{右-右失衡（RR）}：如果父节点的右子树比左子树重，并且右子树的右子树比左子树重，执行单左旋。
    \item \textbf{左-右失衡（LR）}：如果父节点的左子树比右子树重，并且左子树的右子树比左子树重，先对左子树进行单左旋，然后对父节点进行单右旋。
    \item \textbf{右-左失衡（RL）}：如果父节点的右子树比左子树重，并且右子树的左子树比右子树重，先对右子树进行单右旋，然后对父节点进行单左旋。
\end{enumerate}

通过这四种旋转操作，我们能够恢复树的平衡，确保 AVL 树始终满足平衡条件。
该方法可以有效地保证树的结构不会被破坏，同时避免直接在右子树中删除最小节点而导致树的不平衡。
\end{document}
